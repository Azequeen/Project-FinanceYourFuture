"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.readBlockMap = exports.DifferentialDownloader = exports.DifferentialDownloaderOptions = undefined;

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = require("bluebird-lst");
}

var _bluebirdLst2;

function _load_bluebirdLst2() {
    return _bluebirdLst2 = _interopRequireDefault(require("bluebird-lst"));
}

let readBlockMap = exports.readBlockMap = (() => {
    var _ref = (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* (data) {
        return JSON.parse((yield inflateRaw(data)).toString());
    });

    return function readBlockMap(_x) {
        return _ref.apply(this, arguments);
    };
})();

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = require("builder-util-runtime");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _DataSplitter;

function _load_DataSplitter() {
    return _DataSplitter = require("./DataSplitter");
}

var _downloadPlanBuilder;

function _load_downloadPlanBuilder() {
    return _downloadPlanBuilder = require("./downloadPlanBuilder");
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const inflateRaw = (_bluebirdLst2 || _load_bluebirdLst2()).default.promisify(require("zlib").inflateRaw);
class DifferentialDownloaderOptions {}
exports.DifferentialDownloaderOptions = DifferentialDownloaderOptions;
class DifferentialDownloader {
    constructor(blockAwareFileInfo, httpExecutor, options) {
        this.blockAwareFileInfo = blockAwareFileInfo;
        this.httpExecutor = httpExecutor;
        this.options = options;
        this.logger = options.logger;
        this.baseRequestOptions = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).configureRequestOptionsFromUrl)(options.newUrl, {});
    }
    get signatureSize() {
        return 0;
    }
    createRequestOptions(method = "get") {
        return Object.assign({}, this.baseRequestOptions, { method, headers: Object.assign({}, this.options.requestHeaders, { Accept: "*/*" }) });
    }
    doDownload(oldBlockMap, newBlockMap) {
        // we don't check other metadata like compressionMethod - generic check that it is make sense to differentially update is suitable for it
        if (oldBlockMap.version !== newBlockMap.version) {
            throw new Error(`version is different (${oldBlockMap.version} - ${newBlockMap.version}), full download is required`);
        }
        const logger = this.logger;
        const operations = (0, (_downloadPlanBuilder || _load_downloadPlanBuilder()).computeOperations)(oldBlockMap, newBlockMap, logger);
        if (logger.debug != null) {
            logger.debug(JSON.stringify(operations, null, 2));
        }
        let downloadSize = 0;
        let copySize = 0;
        for (const operation of operations) {
            const length = operation.end - operation.start;
            if (operation.kind === (_downloadPlanBuilder || _load_downloadPlanBuilder()).OperationKind.DOWNLOAD) {
                downloadSize += length;
            } else {
                copySize += length;
            }
        }
        const newPackageSize = this.blockAwareFileInfo.size;
        if (downloadSize + copySize + (this.fileMetadataBuffer == null ? 0 : this.fileMetadataBuffer.length) + this.signatureSize !== newPackageSize) {
            throw new Error(`Internal error, size mismatch: downloadSize: ${downloadSize}, copySize: ${copySize}, newPackageSize: ${newPackageSize}`);
        }
        logger.info(`Full: ${formatBytes(newPackageSize)}, To download: ${formatBytes(downloadSize)} (${Math.round(downloadSize / (newPackageSize / 100))}%)`);
        return this.downloadFile(operations);
    }
    downloadFile(tasks) {
        var _this = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const signature = _this.signatureSize === 0 ? null : yield _this.readRemoteBytes(0, _this.signatureSize - 1);
            const oldFileFd = yield (0, (_fsExtraP || _load_fsExtraP()).open)(_this.options.oldFile, "r");
            const newFileFd = yield (0, (_fsExtraP || _load_fsExtraP()).open)(_this.options.newFile, "w");
            const fileOut = (0, (_fsExtraP || _load_fsExtraP()).createWriteStream)(_this.options.newFile, { fd: newFileFd });
            yield new (_bluebirdLst2 || _load_bluebirdLst2()).default(function (resolve, reject) {
                const streams = [];
                const digestTransform = new (_builderUtilRuntime || _load_builderUtilRuntime()).DigestTransform(_this.blockAwareFileInfo.sha512);
                // to simply debug, do manual validation to allow file to be fully written
                digestTransform.isValidateOnEnd = false;
                streams.push(digestTransform);
                fileOut.on("finish", function () {
                    fileOut.close(function () {
                        try {
                            digestTransform.validate();
                        } catch (e) {
                            reject(e);
                            return;
                        }
                        resolve();
                    });
                });
                streams.push(fileOut);
                let lastStream = null;
                for (const stream of streams) {
                    stream.on("error", reject);
                    if (lastStream == null) {
                        lastStream = stream;
                    } else {
                        lastStream = lastStream.pipe(stream);
                    }
                }
                const firstStream = streams[0];
                const w = function (taskOffset) {
                    if (taskOffset >= tasks.length) {
                        if (_this.fileMetadataBuffer != null) {
                            firstStream.write(_this.fileMetadataBuffer);
                        }
                        firstStream.end();
                        return;
                    }
                    const nextOffset = taskOffset + (_this.options.useMultipleRangeRequest === false ? 1 : 1000);
                    _this.executeTasks({
                        tasks,
                        start: taskOffset,
                        end: Math.min(tasks.length, nextOffset),
                        oldFileFd
                    }, firstStream, function () {
                        return w(nextOffset);
                    }, reject);
                };
                if (signature == null) {
                    w(0);
                } else {
                    firstStream.write(signature, function () {
                        return w(0);
                    });
                }
            }).then(function () {
                return (0, (_fsExtraP || _load_fsExtraP()).close)(oldFileFd);
            }).catch(function (error) {
                (0, (_fsExtraP || _load_fsExtraP()).closeSync)(oldFileFd);
                (0, (_fsExtraP || _load_fsExtraP()).closeSync)(newFileFd);
                throw error;
            });
        })();
    }
    executeTasks(options, out, resolve, reject) {
        let ranges = "bytes=";
        let partCount = 0;
        const partIndexToTaskIndex = new Map();
        const partIndexToLength = [];
        for (let i = options.start; i < options.end; i++) {
            const task = options.tasks[i];
            if (task.kind === (_downloadPlanBuilder || _load_downloadPlanBuilder()).OperationKind.DOWNLOAD) {
                ranges += `${task.start}-${task.end - 1}, `;
                partIndexToTaskIndex.set(partCount, i);
                partCount++;
                partIndexToLength.push(task.end - task.start);
            }
        }
        if (partCount <= 1) {
            // the only remote range - copy
            const w = index => {
                if (index >= options.end) {
                    resolve();
                    return;
                }
                const task = options.tasks[index++];
                if (task.kind === (_downloadPlanBuilder || _load_downloadPlanBuilder()).OperationKind.COPY) {
                    (0, (_DataSplitter || _load_DataSplitter()).copyData)(task, out, options.oldFileFd, reject, () => w(index));
                } else {
                    const requestOptions = this.createRequestOptions("get");
                    requestOptions.headers.Range = `bytes=${task.start}-${task.end - 1}`;
                    const request = this.httpExecutor.doRequest(requestOptions, response => {
                        if (!checkIsRangesSupported(response, reject)) {
                            return;
                        }
                        response.pipe(out, {
                            end: false
                        });
                        response.once("end", () => w(index));
                    });
                    this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
                    request.end();
                }
            };
            w(options.start);
            return;
        }
        const requestOptions = this.createRequestOptions("get");
        requestOptions.headers.Range = ranges.substring(0, ranges.length - 2);
        const request = this.httpExecutor.doRequest(requestOptions, response => {
            if (!checkIsRangesSupported(response, reject)) {
                return;
            }
            const contentType = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeGetHeader)(response, "content-type");
            const m = /^multipart\/.+?(?:; boundary=(?:(?:"(.+)")|(?:([^\s]+))))$/i.exec(contentType);
            if (m == null) {
                reject(new Error(`Content-Type "multipart/byteranges" is expected, but got "${contentType}"`));
                return;
            }
            const dicer = new (_DataSplitter || _load_DataSplitter()).DataSplitter(out, options, partIndexToTaskIndex, m[1] || m[2], partIndexToLength, resolve);
            dicer.on("error", reject);
            response.pipe(dicer);
        });
        this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
        request.end();
    }
    readRemoteBytes(start, endInclusive) {
        var _this2 = this;

        return (0, (_bluebirdLst || _load_bluebirdLst()).coroutine)(function* () {
            const buffer = Buffer.allocUnsafe(endInclusive + 1 - start);
            const requestOptions = _this2.createRequestOptions();
            requestOptions.headers.Range = `bytes=${start}-${endInclusive}`;
            let position = 0;
            yield _this2.request(requestOptions, function (chunk) {
                chunk.copy(buffer, position);
                position += chunk.length;
            });
            return buffer;
        })();
    }
    request(requestOptions, dataHandler) {
        return new (_bluebirdLst2 || _load_bluebirdLst2()).default((resolve, reject) => {
            const request = this.httpExecutor.doRequest(requestOptions, response => {
                if (!checkIsRangesSupported(response, reject)) {
                    return;
                }
                response.on("data", dataHandler);
                response.on("end", () => {
                    resolve();
                });
            });
            this.httpExecutor.addErrorAndTimeoutHandlers(request, reject);
            request.end();
        });
    }
}
exports.DifferentialDownloader = DifferentialDownloader;

function formatBytes(value, symbol = " KB") {
    return new Intl.NumberFormat("en").format((value / 1024).toFixed(2)) + symbol;
}
function checkIsRangesSupported(response, reject) {
    // Electron net handles redirects automatically, our NodeJS test server doesn't use redirects - so, we don't check 3xx codes.
    if (response.statusCode >= 400) {
        reject((0, (_builderUtilRuntime || _load_builderUtilRuntime()).createHttpError)(response));
        return false;
    }
    if (response.statusCode !== 206) {
        const acceptRanges = (0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeGetHeader)(response, "accept-ranges");
        if (acceptRanges == null || acceptRanges === "none") {
            reject(new Error("Server doesn't support Accept-Ranges"));
            return false;
        }
    }
    return true;
}
//# sourceMappingURL=DifferentialDownloader.js.map