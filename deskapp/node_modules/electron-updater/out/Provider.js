"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Provider = undefined;
exports.findFile = findFile;
exports.parseUpdateInfo = parseUpdateInfo;
exports.getFileList = getFileList;
exports.resolveFiles = resolveFiles;

var _builderUtilRuntime;

function _load_builderUtilRuntime() {
    return _builderUtilRuntime = require("builder-util-runtime");
}

var _jsYaml;

function _load_jsYaml() {
    return _jsYaml = require("js-yaml");
}

var _main;

function _load_main() {
    return _main = require("./main");
}

class Provider {
    constructor(executor, useMultipleRangeRequest = true) {
        this.executor = executor;
        this.useMultipleRangeRequest = useMultipleRangeRequest;
    }
    get fileExtraDownloadHeaders() {
        return null;
    }
    setRequestHeaders(value) {
        this.requestHeaders = value;
    }
    httpRequest(url, headers, cancellationToken) {
        return this.executor.request(this.createRequestOptions(url, headers), cancellationToken);
    }
    createRequestOptions(url, headers) {
        const result = {};
        if (this.requestHeaders == null) {
            if (headers != null) {
                result.headers = headers;
            }
        } else {
            result.headers = headers == null ? this.requestHeaders : Object.assign({}, this.requestHeaders, headers);
        }
        result.protocol = url.protocol;
        result.hostname = url.hostname;
        if (url.port) {
            result.port = url.port;
        }
        result.path = url.pathname + url.search;
        return result;
    }
}
exports.Provider = Provider;
function findFile(files, extension, not) {
    if (files.length === 0) {
        throw new Error("No files provided");
    }
    const result = files.find(it => it.url.pathname.toLowerCase().endsWith(`.${extension}`));
    if (result != null) {
        return result;
    } else if (not == null) {
        return files[0];
    } else {
        return files.find(fileInfo => !not.some(ext => fileInfo.url.pathname.toLowerCase().endsWith(`.${ext}`)));
    }
}
function parseUpdateInfo(rawData, channelFile, channelFileUrl) {
    if (rawData == null) {
        throw new Error(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): rawData: null`);
    }
    let result;
    try {
        result = (0, (_jsYaml || _load_jsYaml()).safeLoad)(rawData);
    } catch (e) {
        throw new Error(`Cannot parse update info from ${channelFile} in the latest release artifacts (${channelFileUrl}): ${e.stack || e.message}, rawData: ${rawData}`);
    }
    return result;
}
function getFileList(updateInfo) {
    const files = updateInfo.files;
    if (files != null && files.length > 0) {
        return files;
    }
    if (updateInfo.path != null) {
        return [{
            url: updateInfo.path,
            sha512: updateInfo.sha512
        }];
    } else {
        throw new Error(`No files provided: ${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeStringifyJson)(updateInfo)}`);
    }
}
function resolveFiles(updateInfo, baseUrl, pathTransformer = p => p) {
    const files = getFileList(updateInfo);
    const result = files.map(fileInfo => {
        if (fileInfo.sha2 == null && fileInfo.sha512 == null) {
            throw new Error(`Update info doesn't contain nor sha256 neither sha512 checksum: ${(0, (_builderUtilRuntime || _load_builderUtilRuntime()).safeStringifyJson)(fileInfo)}`);
        }
        return {
            url: (0, (_main || _load_main()).newUrlFromBase)(pathTransformer(fileInfo.url), baseUrl),
            info: fileInfo
        };
    });
    const packages = updateInfo.packages;
    const packageInfo = packages == null ? null : packages[process.arch] || packages.ia32;
    if (packageInfo != null) {
        result[0].packageInfo = Object.assign({}, packageInfo, { path: (0, (_main || _load_main()).newUrlFromBase)(pathTransformer(packageInfo.path), baseUrl).href });
    }
    return result;
}
//# sourceMappingURL=Provider.js.map